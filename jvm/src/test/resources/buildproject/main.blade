This is an actual, working Blade program.


We'll define a sample value here.

[groovy
	import com.rocketnia.blade.*
	
	define( [ "out", "sample-var" ], BladeString.of( "sample-val" ) )
]


In order to do that, we define the "groovy" top-level op. We do that
here, using the existing "blade" top-level op. Note that this is sort
of an unnecessary step, since the "groovy" op isn't much simpler to
use than the "blade" op.

What we're demonstrating here is that it doesn't matter what order
these definitions come in.

[blade base jvm-blade exports groovy-eval
	import com.rocketnia.blade.*
	import com.rocketnia.blade.declare.*
	
	softAsk( [ "base", "blade", "exports", "top-level-op-token" ]
	) { BuiltIn.leadHardAsk( it ) { topLevelOpToken -> softAsk(
		[ "base", "jvm-blade", "exports", "groovy-eval" ] ) { define(
		[ "model", "blade", path, "private", topLevelOpToken,
			"groovy" ],
		it
	) } } }
]
